---
phase: 07-core-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/core/process.go
  - internal/core/updater.go
  - internal/api/core.go
  - internal/api/routes.go
autonomous: true

must_haves:
  truths:
    - "Admin can fetch list of sing-box releases from GitHub API"
    - "Admin can update sing-box to latest version via API"
    - "Admin can rollback to previous installed version via API"
    - "Update flow: stop → backup → replace → start; auto-restore on failure"
  artifacts:
    - path: "internal/core/updater.go"
      provides: "CoreUpdater: fetch, download, extract, backup, atomic replace, restart"
      min_lines: 150
    - path: "internal/core/process.go"
      provides: "Explicit binary path support for managed updates"
      contains: "binaryPath"
    - path: "internal/api/core.go"
      provides: "GET /versions, POST /update, POST /rollback"
      contains: "versions"
  key_links:
    - from: "internal/core/updater.go"
      to: "internal/core/process.go"
      via: "ProcessManager with binary path"
      pattern: "binaryPath"
    - from: "internal/api/core.go"
      to: "internal/core/updater.go"
      via: "CoreUpdater.ListReleases, Update, Rollback"
      pattern: "CoreUpdater"
---

<objective>
Backend: CoreUpdater + sing-box binary path + API for versions, update, rollback.

Purpose: Phase 7 requires admin to update and rollback sing-box from the panel. Backend must fetch releases from GitHub, download platform binary, replace atomically with backup, and restart. ProcessManager must use explicit binary path so the panel owns the binary location.

Output: CoreUpdater; ProcessManager with binary path; GET /api/core/versions, POST /api/core/update, POST /api/core/rollback.
</objective>

<execution_context>
@/home/whj/.claude/get-shit-done/workflows/execute-plan.md
@/home/whj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-core-management/07-RESEARCH.md
@.planning/phases/07-core-management/07-CONTEXT.md
@internal/core/process.go
@internal/core/config.go
@internal/api/core.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: ProcessManager binary path + CoreUpdater</name>
  <files>internal/core/process.go, internal/core/updater.go</files>
  <action>
ProcessManager binary path:

- Add binaryPath string field. Resolve: if SINGBOX_BINARY_PATH env set, use it and os.MkdirAll(filepath.Dir(binaryPath), 0755); else binaryPath = "" (backward compat: use LookPath).
- Available(): if binaryPath set, os.Stat(binaryPath)==nil; else exec.LookPath("sing-box").
- Version(), Check(), Restart(): if binaryPath set, exec.Command(binaryPath, ...); else exec.Command("sing-box", ...).
- For Restart: stop via pkill -x sing-box (same as now); start via exec.Command(binaryPath or "sing-box", "run", "-c", configPath).

CoreUpdater (internal/core/updater.go):

- NewCoreUpdater(binaryPath string) \*CoreUpdater. When binaryPath empty, Update() and Rollback() return error "请设置 SINGBOX_BINARY_PATH 以启用核心更新".
- ListReleases() ([]Release, error): GET https://api.github.com/repos/SagerNet/sing-box/releases. Parse JSON: tag_name, prerelease, assets[].name, assets[].browser_download_url. Filter: skip draft. Map to Release{Tag: tag_name, Version: strings.TrimPrefix(tag_name, "v"), Prerelease: prerelease}. Return as-is (API returns reverse chronological). Latest stable = first with prerelease false; latest including pre = first.
- assetForPlatform(version string) (string, string): map runtime.GOOS (linux, darwin, windows) and runtime.GOARCH (amd64, arm64, 386, arm) to sing-box asset name. Format: sing-box-{version}-{os}-{arch}.tar.gz. e.g. linux/amd64 -> linux-amd64. Handle arm -> armv7, 386 -> 386 per RESEARCH. Return asset name and url (from releases list).
- Update() error: (1) Stop: pkill -x sing-box, time.Sleep(100ms). (2) Fetch latest release (first non-draft), get asset for platform. (3) Download to temp file. (4) Extract: archive/tar + compress/gzip; find entry ending with /sing-box. Extract to temp dir. (5) Backup: copy current binary to binaryPath+".backup" (os.Remove if exists). (6) Atomic replace: tmpPath -> binaryPath via os.Rename. Chmod 0755. (7) Verify: pm.Check(configPath); on failure, restore backup and return error. (8) Start: pm.Restart(configPath). On any step failure between 2-7, restore backup if backup was created.
- Rollback() error: if no backup file exists, return error. Stop, swap backup with current (atomic rename), Chmod 0755, Restart, return nil.
- Keep exactly 1 backup (binaryPath+".backup") per RESEARCH. No version list on disk.
  </action>
  <verify>go build ./...; grep -l CoreUpdater internal/core/updater.go; grep -l binaryPath internal/core/process.go</verify>
  <done>ProcessManager uses binary path; CoreUpdater fetches, downloads, replaces atomically, keeps backup for rollback</done>
  </task>

<task type="auto">
  <name>Task 2: API routes for versions, update, rollback</name>
  <files>internal/api/core.go, internal/api/routes.go</files>
  <action>
Extend internal/api/core.go:

- VersionsHandler: GET. Call core.NewCoreUpdater(binaryPath()).ListReleases(). Return JSON: {releases: [{tag, version, prerelease, ...}]}. Use RequireAuth. 200 on success.
- UpdateHandler: POST. Call CoreUpdater.Update(). On success: 200 {ok: true}. On error: 400/500 {error: "..."}. Use RequireAuth.
- RollbackHandler: POST. Call CoreUpdater.Rollback(). On success: 200 {ok: true}. On error (no backup): 400 {error: "暂无备份可回滚"}. Use RequireAuth.

Add helper binaryPath() in core.go matching ProcessManager resolution: SINGBOX_BINARY_PATH or filepath.Join(dataDir, "bin", "sing-box").

routes.go: add under /api/core (RequireAuth):

- r.Get("/versions", VersionsHandler(sm))
- r.Post("/update", UpdateHandler(sm))
- r.Post("/rollback", RollbackHandler(sm))
  </action>
  <verify>go build ./...; curl -s http://localhost:8080/api/core/versions -H "Cookie: ..." | jq '.releases | length'</verify>
  <done>GET /versions returns releases; POST /update updates; POST /rollback restores backup</done>
  </task>

</tasks>

<verification>
- go build ./...
- GET /api/core/versions returns releases array with tag_name, prerelease
- POST /api/core/update (with valid auth) updates binary; on failure returns error message
- POST /api/core/rollback restores backup when backup exists
</verification>

<success_criteria>

- Versions API returns GitHub releases; Update and Rollback APIs work end-to-end
- Update flow: stop → backup → replace → start; auto-restore on failure
- Rollback uses single .backup file
  </success_criteria>

<output>
After completion, create `.planning/phases/07-core-management/07-01-SUMMARY.md`
</output>
