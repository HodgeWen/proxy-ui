---
phase: 05-subscription-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/db/user.go
  - internal/core/subscription.go
  - internal/api/subscription.go
  - internal/api/routes.go
autonomous: true

must_haves:
  truths:
    - "Each user has a unique subscription token stored in DB"
    - "GET /sub/{token} returns Base64 proxy list for non-Clash clients"
    - "GET /sub/{token} returns ClashMeta YAML for Clash UA or ?format=clash"
    - "Disabled or expired users receive 403 on subscription link"
    - "Response includes subscription-userinfo header (lowercase)"
  artifacts:
    - path: internal/db/user.go
      provides: SubscriptionToken column, GetUserBySubscriptionToken
      contains: "SubscriptionToken"
    - path: internal/core/subscription.go
      provides: Subscription content generation (Base64 + Clash)
      exports: ["GenerateBase64", "GenerateClash", "BuildUserinfoHeader"]
    - path: internal/api/subscription.go
      provides: GET /sub/{token} handler (no auth)
      exports: ["SubscriptionHandler"]
  key_links:
    - from: internal/api/subscription.go
      to: internal/db/user.go
      via: "GetUserBySubscriptionToken"
      pattern: "GetUserBySubscriptionToken"
    - from: internal/api/subscription.go
      to: internal/core/subscription.go
      via: "GenerateBase64/GenerateClash"
      pattern: "GenerateBase64|GenerateClash"
    - from: internal/core/subscription.go
      to: internal/db/inbound.go
      via: "User Inbounds for share links"
      pattern: "Inbounds"
---

<objective>
Subscription token on User model; SubscriptionGenerator for Base64 and ClashMeta formats; GET /sub/{token} public endpoint with UA/query format detection and 403 for disabled/expired.

Purpose: SUB-01, SUB-02, SUB-03 — unique subscription link per user returning Base64 or Clash format.
Output: User.SubscriptionToken, internal/core/subscription.go, GET /sub/{token} handler.
</objective>

<execution_context>
@/home/whj/.claude/get-shit-done/workflows/execute-plan.md
@/home/whj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-subscription-system/05-CONTEXT.md
@.planning/phases/05-subscription-system/05-RESEARCH.md
@internal/db/user.go
@internal/db/inbound.go
@internal/core/generator.go
@internal/api/routes.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: User model subscription token</name>
  <files>internal/db/user.go</files>
  <action>
Add SubscriptionToken to User model and DB layer:

1. User struct: add SubscriptionToken string `gorm:"size:32;uniqueIndex"` (short token, not UUID per CONTEXT)
2. Helper generateSubscriptionToken(): use crypto/rand, 16 chars from charset a-z0-9 (per RESEARCH; Claude's discretion for length)
3. GetUserBySubscriptionToken(token string) (\*User, error): find user by subscription_token, Preload Inbounds
4. CreateUser: if SubscriptionToken empty, set to generateSubscriptionToken() before insert
5. Backfill existing users: after migration, run a one-time update — for each user where subscription_token = '', set generateSubscriptionToken()

Avoid: Using User.UUID as token (user wants short token); math/rand (use crypto/rand per RESEARCH).
</action>
<verify>go build ./... passes; new user created has non-empty subscription_token; GetUserBySubscriptionToken returns correct user</verify>
<done>User has SubscriptionToken; CreateUser auto-generates; GetUserBySubscriptionToken works; existing users backfilled</done>
</task>

<task type="auto">
  <name>Task 2: SubscriptionGenerator (Base64 + Clash)</name>
  <files>internal/core/subscription.go</files>
  <action>
Create internal/core/subscription.go with subscription content generation:

1. BuildUserinfoHeader(u \*db.User) string:
   - Format: "upload=X; download=Y; total=Z; expire=T" (lowercase header name per RESEARCH Pitfall 2)
   - upload/download: use TrafficUsed/2 each (placeholder until Phase 6)
   - total: TrafficLimit; omit if 0
   - expire: Unix sec if ExpireAt set; omit if nil

2. Extract host from inbound for share links (RESEARCH Pitfall 1): Use tls.server_name from inbound ConfigJSON. If absent, try config["host"]. Fallback: empty string (document TLS should have server_name).

3. GenerateBase64(u \*db.User) ([]byte, error):
   - For each inbound in u.Inbounds: if VLESS, build vless://uuid@host:port?type=tcp&security=tls&flow=xtls-rprx-vision#name; if Hysteria2, build hysteria2://password@host:port/?sni=host#name
   - Join links with newline; Base64 encode; return
   - Only include inbounds where user is valid (GetUsersForInbound); user's inbounds are already filtered by assignment

4. GenerateClash(u \*db.User) ([]byte, error):
   - Use gopkg.in/yaml.v3 for ClashMeta YAML
   - Proxies array: type vless/hysteria2 per inbound; VLESS: name, server, port, uuid, network tcp, servername, flow xtls-rprx-vision, tls true; Hysteria2: name, server, port, password, sni
   - Return YAML bytes

5. GetNodeLinks(u \*db.User) []struct{Name, Link string}: same link-building logic for admin UI per-node copy (used by Plan 02).

Add go get gopkg.in/yaml.v3 if not present.
</action>
<verify>go build ./... passes; GenerateBase64 returns valid Base64; GenerateClash returns valid YAML with proxies</verify>
<done>SubscriptionGenerator produces Base64 and ClashMeta output; host from tls.server_name; userinfo header format correct</done>
</task>

<task type="auto">
  <name>Task 3: GET /sub/{token} handler and route</name>
  <files>internal/api/subscription.go, internal/api/routes.go</files>
  <action>
Create subscription handler and register outside /api (no auth per CONTEXT):

1. internal/api/subscription.go:
   - SubscriptionHandler(w, r): token from chi.URLParam(r, "token")
   - user, err := db.GetUserBySubscriptionToken(token); if err or nil, http.Error 404
   - if !user.Enabled, http.Error 403
   - if user.ExpireAt != nil && !user.ExpireAt.After(time.Now().UTC()), http.Error 403
   - if user.TrafficLimit > 0 && user.TrafficUsed >= user.TrafficLimit, http.Error 403
   - Format detection: wantClash := r.URL.Query().Get("format") == "clash" || strings.Contains(strings.ToLower(r.Header.Get("User-Agent")), "clash") (per RESEARCH Pitfall 3: default Base64 for unknown)
   - body := subscription.GenerateClash(user) or GenerateBase64(user)
   - w.Header().Set("subscription-userinfo", subscription.BuildUserinfoHeader(user))
   - w.Header().Set("Content-Type", "text/plain; charset=utf-8")
   - w.Write(body)

2. routes.go: Register r.Get("/sub/{token}", api.SubscriptionHandler) BEFORE r.Route("/api", ...) or before spaHandler catch-all, so /sub/xyz is handled. Chi matches specific routes first; add early: r.Get("/sub/{token}", ...).
   </action>
   <verify>curl -s http://localhost:PORT/sub/INVALID_TOKEN returns 404; curl valid token returns 200 with Base64 body; curl -H "User-Agent: ClashMeta" valid token returns YAML; disabled user returns 403</verify>
   <done>GET /sub/{token} returns Base64 or Clash per format; 403 for disabled/expired/over-limit; subscription-userinfo header present</done>
   </task>

</tasks>

<verification>
- go build ./...
- curl /sub/{valid_token} returns 200 + Base64
- curl -H "User-Agent: ClashMeta" /sub/{valid_token} returns 200 + YAML
- curl /sub/{token}?format=clash returns YAML
- Disabled user: 403
- Subscription-userinfo header present in response
</verification>

<success_criteria>

- User.SubscriptionToken exists; GET /sub/{token} returns Base64 or ClashMeta
- Disabled/expired users get 403
- subscription-userinfo header in response
  </success_criteria>

<output>
After completion, create `.planning/phases/05-subscription-system/05-01-SUMMARY.md`
</output>
