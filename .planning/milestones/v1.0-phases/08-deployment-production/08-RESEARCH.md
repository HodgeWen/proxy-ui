# Phase 8: Deployment & Production - Research

**Researched:** 2026-02-12
**Domain:** Go deployment, Docker, install scripts, GitHub Actions, reverse proxy
**Confidence:** HIGH

## Summary

Phase 8 adds three deployment methods: Docker Compose, bash install script, and single binary. The panel serves HTTP only; HTTPS is handled by reverse proxy (Nginx/Caddy). Panel config is file-based; on first run, a default config is auto-generated. Docker uses a single container with s-ui + sing-box; data via bind mount; config via mounted config.json. The install script uses `curl | bash` style, installs only s-ui binary (sing-box via panel), creates systemd service, supports install/update/uninstall. Single binary uses Go embed for frontend; GitHub Actions on tag builds linux-amd64 and linux-arm64 and publishes to GitHub Release.

**Primary recommendation:** Use multi-stage Dockerfile (build frontend + Go backend, embed dist); single runtime image with s-ui + sing-box binaries; bind mount for data and config. Install script: detect arch, download latest release binary, extract, install systemd unit, optionally prompt for port/settings. GitHub Actions: on push tags v*, build both arches, upload s-ui-linux-amd64 and s-ui-linux-arm64 to release.

---

<user_constraints>

## User Constraints (from CONTEXT.md)

### Locked Decisions

### HTTPS 实现方式
- 面板本身不内置 TLS/ACME，HTTPS 通过反向代理（Nginx/Caddy）处理
- 面板默认 HTTP，监听端口可配置
- HTTP 跳转、证书管理等均由反向代理负责，面板不涉及
- 提供 Nginx/Caddy 反向代理配置示例（文档/README 级别）

### Docker 部署体验
- 单容器包含 s-ui + sing-box，不做多容器拆分
- 数据持久化使用 bind mount 挂载主机目录（非 named volume）
- 配置传入方式以配置文件为主，挂载 config.json
- 容器内 s-ui 与 sing-box 通过 localhost 通信

### 安装脚本行为
- 脚本只安装 s-ui 二进制，sing-box 由用户自行安装或通过面板内核管理下载
- 创建 systemd service（s-ui.service），开机自启
- 交互式安装：提示用户输入端口、管理员密码等
- 支持完整生命周期子命令：install / update / uninstall

### 单二进制发布
- 前端资源通过 Go embed 编译时嵌入到二进制中
- 只支持 Linux 平台：amd64 + arm64 两个架构
- 使用 GitHub Actions CI：push tag 自动触发构建和 Release 发布
- 首次运行时自动生成默认配置文件（无需手动创建 config.json）

### Claude's Discretion
- Dockerfile 基础镜像选择和多阶段构建细节
- 安装脚本中的错误处理和回退逻辑
- GitHub Actions workflow 的具体 step 设计
- docker-compose.yml 的端口映射和卷挂载具体路径
- 反向代理配置示例的具体内容

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope

</user_constraints>

---

## Standard Stack

### Core (existing)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Go `embed` | stdlib | Frontend assets | Already in web/embed.go; `//go:embed dist/*`; fs.Sub for dist |
| `io/fs` | stdlib | fs.Sub for embed | Strip dist prefix from embed.FS |
| `golang.org/x/crypto/bcrypt` | — | Password hashing | Used by auth setup |

### Build & Deploy
| Tool | Purpose | When to Use |
|------|---------|-------------|
| Vite | Frontend build | `bun run build` produces web/dist |
| Go build | Backend binary | `-ldflags="-s -w"` for smaller binary |
| Docker multi-stage | Image build | Builder stage + minimal runtime stage |
| GitHub Actions | CI | Release on tag push |

### sing-box
| Source | URL | Purpose |
|--------|-----|---------|
| GitHub Releases | SagerNet/sing-box | Asset name: `sing-box-{version}-linux-{amd64\|arm64}.tar.gz` |
| Extract | tar.gz | Contains sing-box binary |

### Reverse Proxy (examples only)
| Tool | Purpose | When to Use |
|------|---------|-------------|
| Caddy | HTTPS + reverse proxy | `example.com { reverse_proxy :8080 }` |
| Nginx | HTTPS + reverse proxy | `proxy_pass http://127.0.0.1:8080` |

**Installation:** No new deps. Existing: `go build`, `bun run build`, Docker, GitHub Actions.

---

## Architecture Patterns

### Recommended Project Structure

```
s-ui/
├── .github/
│   └── workflows/
│       └── release.yml          # build + publish on tag
├── cmd/
│   └── server/
│       └── main.go              # reads config, serves HTTP
├── web/
│   ├── embed.go                 # //go:embed dist/*
│   ├── dist/                    # generated by build-frontend
│   └── src/
├── internal/
│   └── core/
│       └── config.go            # panel config load/save
├── Dockerfile                   # multi-stage
├── docker-compose.yml           # example
├── install.sh                   # curl|bash install script
└── docs/
    └── reverse-proxy.md         # Nginx/Caddy examples
```

### Pattern 1: Go embed for SPA

**What:** Embed frontend dist at compile time. Use `fs.Sub` to serve from dist subdir.

**When to use:** Single binary deployment.

**Example (existing):**
```go
// web/embed.go
package web
import "embed"
//go:embed dist/*
var FS embed.FS

// cmd/server/main.go
distFS, _ := fs.Sub(web.FS, "dist")
r := api.Routes(distFS, sm)
```

**Build order:** `make build-frontend` → `make build-backend` (must run before `go build`).

**Source:** pkg.go.dev/embed

### Pattern 2: Panel config file + auto-generate

**What:** Panel reads config from `config.json` (or env). On first run, if file missing, write default and proceed.

**When to use:** Any deployment where config is file-based.

**Example:**
```go
type PanelConfig struct {
    Addr             string `json:"addr"`
    SessionSecret    string `json:"session_secret"`
    DataDir          string `json:"data_dir"`
    SingboxConfigPath string `json:"singbox_config_path"`
    SingboxBinaryPath string `json:"singbox_binary_path"`
}

func LoadConfig(path string) (*PanelConfig, error) {
    if _, err := os.Stat(path); os.IsNotExist(err) {
        cfg := defaultConfig()
        if err := json.MarshalIndent(cfg); err != nil { return nil, err }
        os.WriteFile(path, b, 0644)
        return cfg, nil
    }
    // read and unmarshal
}
```

**Config path:** `CONFIG_PATH` env or default `./config.json`. Docker: mount at `/data/config.json` (or similar).

### Pattern 3: Docker single container (s-ui + sing-box)

**What:** One image with both s-ui binary and sing-box binary. s-ui runs as main process; sing-box started by s-ui via ProcessManager. Data and config via bind mount.

**When to use:** Docker deployment per CONTEXT.

**Example (Dockerfile):**
```dockerfile
# Stage 1: build frontend
FROM node:22-alpine AS frontend
WORKDIR /app/web
COPY web/package.json web/bun.lock ./
RUN bun install --frozen-lockfile
COPY web/ ./
RUN bun run build

# Stage 2: build Go backend
FROM golang:1.25-alpine AS backend
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN cp -r /app/web/dist /tmp/dist  # from frontend stage
RUN CGO_ENABLED=0 go build -ldflags="-s -w" -o /s-ui ./cmd/server

# Stage 3: runtime
FROM alpine:3.20
RUN apk add --no-cache ca-certificates
COPY --from=backend /s-ui /s-ui
# Download sing-box binary (or use COPY from another stage)
RUN ... # download sing-box from GitHub releases
COPY docker-entrypoint.sh /
ENTRYPOINT ["/docker-entrypoint.sh"]
```

**Entrypoint:** Start s-ui and optionally sing-box. Or s-ui starts sing-box via ProcessManager.

### Pattern 4: Install script (curl | bash)

**What:** Script detects OS/arch, downloads `s-ui-linux-{arch}` from GitHub releases, extracts, installs to `/usr/local/s-ui` (or similar), creates systemd unit.

**When to use:** Bare-metal install.

**Example flow (from 3x-ui):**
```bash
#!/bin/bash
[[ $EUID -ne 0 ]] && echo "Need root" && exit 1
arch() { case "$(uname -m)" in x86_64|amd64) echo amd64;; aarch64|arm64) echo arm64;; *) exit 1;; esac; }
tag=$(curl -sL https://api.github.com/repos/OWNER/repo/releases/latest | grep '"tag_name"' | cut -d'"' -f4)
curl -fsL "https://github.com/OWNER/repo/releases/download/${tag}/s-ui-linux-$(arch)" -o /tmp/s-ui
install -m 755 /tmp/s-ui /usr/local/s-ui/s-ui
# systemctl enable s-ui
```

**Subcommands:** `install` (default), `update`, `uninstall`. Use `$0` or `$1` to detect.

### Pattern 5: GitHub Actions release on tag

**What:** On `push: tags: [v*]`, build Go for linux/amd64 and linux/arm64, upload to GitHub Release.

**When to use:** Binary release.

**Example:**
```yaml
on:
  push:
    tags: ['v*']
jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
      - name: Build frontend
        run: cd web && bun install && bun run build
      - name: Build
        run: |
          for arch in amd64 arm64; do
            GOOS=linux GOARCH=$arch go build -ldflags="-s -w" -o s-ui-linux-$arch ./cmd/server
          done
      - uses: softprops/action-gh-release@v2
        with:
          files: s-ui-linux-amd64 s-ui-linux-arm64
```

**Source:** [softprops/action-gh-release](https://github.com/softprops/action-gh-release)

### Anti-Patterns to Avoid

- **Embedding empty dist:** Build frontend before `go build`; otherwise embed captures nothing or stale files.
- **CGO in Docker:** Use `CGO_ENABLED=0` for static binary; avoids glibc in Alpine.
- **HTTPS in panel:** CONTEXT says no TLS in panel; use reverse proxy. Do not add certmagic.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Config parsing | Custom parser | JSON unmarshal | stdlib sufficient; no extra deps |
| Release upload | Manual curl | softprops/action-gh-release | Handles auth, draft, assets |
| sing-box download | Custom fetcher | GitHub API + asset URL | Same pattern as core updater |
| Reverse proxy | In-panel TLS | Nginx/Caddy | CONTEXT locked; proxy handles certs |

**Key insight:** Panel config is simple JSON; no need for viper/koanf. GitHub Release API is well-documented; action-gh-release is standard.

---

## Common Pitfalls

### Pitfall 1: Embed dist before build

**What goes wrong:** `go build` runs before `bun run build`; embed captures empty or outdated dist. SPA returns 404 or broken assets.

**Why it happens:** Makefile or CI runs `go build` without `build-frontend` first.

**How to avoid:** `make build` always runs `build-frontend` first.

**Warning signs:** `dist` empty or missing; `fs.Sub(web.FS, "dist")` fails or serves empty.

### Pitfall 2: Session cookie Secure behind proxy

**What goes wrong:** Panel sets `Cookie.Secure = false`; browser sends cookie over HTTPS. Proxy terminates TLS; panel sees HTTP. Cookie may be rejected or not sent.

**Why it happens:** Panel trusts `X-Forwarded-Proto` or similar; if not set, panel thinks it's HTTP.

**How to avoid:** When behind HTTPS proxy, set `X-Forwarded-Proto: https` in proxy config. Panel can read it and set `Secure = true` for session cookie.

**Warning signs:** Login works over HTTP but not HTTPS; cookies not persisted.

**Current code:** `internal/session/session.go` has `Cookie.Secure = false` with comment "set true when behind HTTPS". Add logic to detect proxy and set Secure.

### Pitfall 3: Config path mismatch

**What goes wrong:** Docker mounts config at `/data/config.json`; panel looks at `./config.json` (current dir). Config not found.

**Why it happens:** Working directory in container differs from mount path.

**How to avoid:** Use `CONFIG_PATH` env or default `./config.json`. Docker: set `CONFIG_PATH=/data/config.json` and mount config at `/data/config.json`.

**Warning signs:** "config not found" or defaults used despite mount.

### Pitfall 4: sing-box binary not in container

**What goes wrong:** s-ui starts; ProcessManager tries to run sing-box; not found.

**Why it happens:** Docker image only has s-ui binary; sing-box not included.

**How to avoid:** Build stage or entrypoint downloads sing-box from GitHub releases or copies from another stage. Place at `/data/bin/sing-box` (or config path).

**Warning signs:** "sing-box not found" in logs; core update fails.

### Pitfall 5: Port already in use

**What goes wrong:** Install script runs; systemd starts; port 8080 (or chosen) in use; service fails.

**Why it happens:** Another service binds to same port.

**How to avoid:** Check `ss -ltn` or `netstat` before install; prompt user for alternative port. Use `is_port_in_use()` helper (like 3x-ui).

---

## Code Examples

### Go embed (existing)

```go
// web/embed.go
package web
import "embed"
//go:embed dist/*
var FS embed.FS

// cmd/server/main.go
distFS, err := fs.Sub(web.FS, "dist")
```

### Caddy reverse proxy (HTTPS)

```caddyfile
example.com {
    reverse_proxy :8080
}
```

Caddy auto-obtains HTTPS cert. Proxies to panel on HTTP.

### Nginx reverse proxy (HTTPS)

```nginx
server {
    listen 443 ssl;
    server_name example.com;
    ssl_certificate /path/to/fullchain.pem;
    ssl_certificate_key /path/to/privkey.pem;

    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

### systemd service

```ini
[Unit]
Description=s-ui Panel
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/s-ui/s-ui
WorkingDirectory=/usr/local/s-ui
Restart=on-failure
RestartSec=5
Environment=CONFIG_PATH=/usr/local/s-ui/config.json

[Install]
WantedBy=multi-user.target
```

### GitHub Actions cross-compile

```yaml
- name: Build
  run: |
    cd web && bun install && bun run build && cd ..
    GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o s-ui-linux-amd64 ./cmd/server
    GOOS=linux GOARCH=arm64 go build -ldflags="-s -w" -o s-ui-linux-arm64 ./cmd/server
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual binary copy | GitHub Actions release | Common | Push tag → auto release |
| Single-stage Docker | Multi-stage | 2017+ | Smaller images |
| Panel TLS | Reverse proxy | CONTEXT | Simpler panel; proxy handles certs |

**Deprecated/outdated:**
- Create React App: Deprecated; use Vite.
- certmagic in panel: CONTEXT says no; use reverse proxy.

---

## Open Questions

1. **Panel config schema**
   - What we know: CONTEXT says config.json mount; first run auto-generate.
   - What's unclear: Exact fields (addr, session_secret, data_dir, singbox_config_path, singbox_binary_path). Session secret: must be random on first run.
   - Recommendation: Define schema in PLAN; include: addr, session_secret (32-byte hex), data_dir, singbox_config_path, singbox_binary_path. Env vars override file (for backward compat).

2. **Docker entrypoint**
   - What we know: Single container with s-ui + sing-box. s-ui spawns sing-box via ProcessManager.
   - What's unclear: Does entrypoint download sing-box at build time or runtime? Build time: fixed version. Runtime: latest.
   - Recommendation: Build time download from GitHub releases (deterministic). Use env or config for version.

3. **Install script install path**
   - What we know: Script installs s-ui binary; systemd service.
   - What's unclear: Path: `/usr/local/s-ui` vs `/opt/s-ui` vs other.
   - Recommendation: `/usr/local/s-ui` (or match 3x-ui). Document in README.

---

## Sources

### Primary (HIGH confidence)
- pkg.go.dev/embed - Go embed package
- Caddy reverse proxy quick-start - caddyserver.com/docs/quick-starts/reverse-proxy
- NGINX reverse proxy docs - docs.nginx.com
- softprops/action-gh-release - GitHub
- 3x-ui install.sh - raw.githubusercontent.com/MHSanaei/3x-ui/main/install.sh
- SagerNet/sing-box releases - api.github.com/repos/SagerNet/sing-box/releases/latest

### Secondary (MEDIUM confidence)
- WebSearch: Docker multi-stage Go build
- WebSearch: GitHub Actions Go cross-compile release

### Tertiary (LOW confidence)
- None

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Go embed, Docker, GitHub Actions are well-documented
- Architecture: HIGH - Patterns from 3x-ui, Caddy, Nginx
- Pitfalls: HIGH - Known from similar projects

**Research date:** 2026-02-12
**Valid until:** 2026-03-31
