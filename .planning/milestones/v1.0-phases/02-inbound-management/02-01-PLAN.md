---
phase: 02-inbound-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/db/inbound.go
  - internal/db/db.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Inbound records can be persisted and retrieved from SQLite"
    - "Inbound model supports both VLESS and Hysteria2 configurations"
  artifacts:
    - path: internal/db/inbound.go
      provides: Inbound model and CRUD operations
      contains: "type Inbound struct"
    - path: internal/db/db.go
      provides: AutoMigrate for Inbound
      contains: "Inbound"
  key_links:
    - from: internal/db/db.go
      to: internal/db/inbound.go
      via: AutoMigrate
      pattern: "AutoMigrate.*Inbound"
---

<objective>
Create Inbound model and DB layer for VLESS and Hysteria2 configurations.

Purpose: DB is source of truth for inbound configs; ConfigGenerator and API will read from here.
Output: internal/db/inbound.go with model + CRUD, db.go updated for AutoMigrate
</objective>

<execution_context>
@/home/whj/.claude/get-shit-done/workflows/execute-plan.md
@/home/whj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-inbound-management/02-RESEARCH.md
@.planning/phases/02-inbound-management/02-CONTEXT.md
@internal/db/admin.go
@internal/db/db.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inbound model definition</name>
  <files>internal/db/inbound.go</files>
  <action>
Create Inbound model in internal/db/inbound.go following admin.go pattern.

Fields:
- ID (uint, primaryKey)
- Tag (string, uniqueIndex, not null) — sing-box inbound tag
- Protocol (string, not null) — "vless" or "hysteria2"
- Listen (string, default "::") — listen address
- ListenPort (uint, not null) — port number
- ConfigJSON (gorm datatypes.JSON or []byte) — stores TLS, transport, and protocol-specific fields. For VLESS: tls{}, transport{}, users[]. For Hysteria2: tls{}, up_mbps, down_mbps, obfs{}, users[].
- CreatedAt, UpdatedAt (time.Time)

Use `gorm.io/datatypes` JSON type for ConfigJSON. ConfigJSON structure: map[string]any with keys like "tls", "transport", "users", "up_mbps", "down_mbps", "obfs" per protocol.

TableName: "inbounds"

Do NOT add user_count column — Phase 4 will add; for now list API returns 0.
</action>
  <verify>go build ./internal/db/...</verify>
  <done>Inbound struct compiles, TableName returns "inbounds"</done>
</task>

<task type="auto">
  <name>Task 2: Inbound CRUD and auto-migrate</name>
  <files>internal/db/inbound.go, internal/db/db.go</files>
  <action>
Add CRUD functions to inbound.go:
- ListInbounds() ([]Inbound, error) — Find all, order by created_at desc
- GetInboundByID(id uint) (*Inbound, error)
- CreateInbound(in *Inbound) error
- UpdateInbound(in *Inbound) error
- DeleteInbound(id uint) error — hard delete

Update internal/db/db.go: add &Inbound{} to AutoMigrate in Init().
</action>
  <verify>go build ./... && go test ./internal/db/... -count=1 2>/dev/null || true</verify>
  <done>CRUD functions exist; db.Init runs AutoMigrate for Inbound</done>
</task>

</tasks>

<verification>
- go build ./...
- Inbound table created when server starts (or run Init manually)
</verification>

<success_criteria>
- Inbound model persists to SQLite with tag, protocol, listen, listen_port, config_json
- CRUD functions available for ConfigGenerator and API
</success_criteria>

<output>
After completion, create `.planning/phases/02-inbound-management/02-01-SUMMARY.md`
</output>
