---
phase: 03-certificate-management
plan: 02
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - internal/db/certificate.go
  - internal/api/certs.go
  - internal/api/routes.go
  - web/src/pages/Certificates.tsx
  - web/src/components/certificates/CertificateTable.tsx
  - web/src/components/certificates/CertificateFormModal.tsx
  - web/src/components/layout/Sidebar.tsx
  - web/src/routes.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can list, add, edit, delete certificates via UI"
    - "Delete is blocked when cert is in use by any inbound"
  artifacts:
    - path: internal/api/certs.go
      provides: Cert CRUD API
      exports: ["GET /api/certs", "GET /api/certs/:id", "POST", "PUT", "DELETE"]
    - path: web/src/pages/Certificates.tsx
      provides: Certificate list page
      min_lines: 50
    - path: web/src/components/certificates/CertificateFormModal.tsx
      provides: Add/edit cert form (name, fullchain_path, privkey_path)
  key_links:
    - from: web/src/pages/Certificates.tsx
      to: /api/certs
      via: useQuery fetch
      pattern: "api/certs"
    - from: internal/api/certs.go
      to: internal/db/certificate.go
      via: db.ListCertificates, CreateCertificate, etc.

---

<objective>
Certificate CRUD API and certificates list/form UI. Block cert delete when in use by any inbound.

Purpose: CRT-01 — admin can manually specify TLS certificate paths (fullchain + privkey) via UI.
Output: /api/certs endpoints; Certificates page with table and form modal; Sidebar certificate link enabled.
</objective>

<execution_context>
@/home/whj/.claude/get-shit-done/workflows/execute-plan.md
@/home/whj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-certificate-management/03-RESEARCH.md
@internal/api/inbounds.go
@internal/api/routes.go
@web/src/pages/Inbounds.tsx
@web/src/components/inbounds/InboundTable.tsx
@web/src/components/inbounds/InboundFormModal.tsx
@web/src/components/layout/Sidebar.tsx
@web/src/routes.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Certificate CRUD API and block delete when in use</name>
  <files>internal/db/certificate.go, internal/api/certs.go, internal/api/routes.go</files>
  <action>
In internal/db/certificate.go, add InboundsReferencingCert(certID uint) ([]string, error):
- List all inbounds; for each, unmarshal config_json; if tls.certificate_id matches certID (handle float64/json.Number from JSON), collect tag
- Return slice of tags of inbounds that reference this cert

Create internal/api/certs.go following inbounds.go pattern:
- certItem struct: id, name, fullchain_path, privkey_path, created_at
- ListCertificatesHandler: GET /api/certs, returns {data: [...]}
- GetCertificateHandler: GET /api/certs/:id, returns single cert
- CreateCertificateHandler: POST, body {name, fullchain_path, privkey_path}; validate non-empty paths; create
- UpdateCertificateHandler: PUT /api/certs/:id, same body
- DeleteCertificateHandler: call db.InboundsReferencingCert(id); if len > 0, return 400 with error like "证书正在被以下入站使用: tag1, tag2"
- All handlers use RequireAuth(sm)
- No config apply on cert mutate (certs are only used when inbound config is applied)

In routes.go, add under RequireAuth:
  r.Route("/certs", func(r chi.Router) {
    r.Get("/", ListCertificatesHandler(sm))
    r.Get("/{id}", GetCertificateHandler(sm))
    r.Post("/", CreateCertificateHandler(sm))
    r.Put("/{id}", UpdateCertificateHandler(sm))
    r.Delete("/{id}", DeleteCertificateHandler(sm))
  })
</action>
  <verify>go build ./... passes; curl -s -b cookies -X GET /api/certs returns 200 with data array</verify>
  <done>Cert CRUD API works; GET list returns certs; DELETE returns 400 when cert in use</done>
</task>

<task type="auto">
  <name>Task 2: Certificates page with table and form modal</name>
  <files>web/src/pages/Certificates.tsx, web/src/components/certificates/CertificateTable.tsx, web/src/components/certificates/CertificateFormModal.tsx, web/src/components/layout/Sidebar.tsx, web/src/routes.tsx</files>
  <action>
Create web/src/components/certificates/CertificateTable.tsx:
- Receives certificates: Array<{id, name, fullchain_path, privkey_path, created_at}>; onEdit(id), onDelete(id) callbacks
- Table columns: 名称, 证书路径, 私钥路径, 创建时间, 操作 (Edit button inline, Delete in DropdownMenu per InboundTable pattern)
- Use shadcn Table, Button, DropdownMenu

Create web/src/components/certificates/CertificateFormModal.tsx:
- Props: open, onOpenChange, onSuccess, certificate?: {id, name, fullchain_path, privkey_path, created_at}
- Form fields: name (required), fullchain_path (required), privkey_path (required)
- react-hook-form + zod, schema: name min 1, path min 1
- POST /api/certs for create, PUT /api/certs/:id for edit
- Toast on success

Create web/src/pages/Certificates.tsx:
- useQuery fetch /api/certs; loading/error states
- "添加证书" button; CertificateTable; CertificateFormModal
- handleAdd, handleEdit(id), handleDelete(id) with window.confirm for delete
- Fetch cert for edit: GET /api/certs/:id when editingId set

In Sidebar.tsx: change certificates nav item disabled: true to disabled: false.

In routes.tsx: add { path: "certificates", element: <Certificates /> } under AppLayout children.
</action>
  <verify>npm run build (or bun run build) passes; visit /certificates shows table and form</verify>
  <done>Certificates page loads; add/edit/delete certs via UI</done>
</task>

</tasks>

<verification>
- go build ./...
- cd web && bun run build
- curl -X GET /api/certs (with auth) returns cert list
- UI: /certificates page shows table, add/edit/delete work
</verification>

<success_criteria>
- Admin can add certificates with name, fullchain_path, privkey_path
- Admin can list, edit, delete certificates
- Delete blocked when cert referenced by inbound
</success_criteria>

<output>
After completion, create `.planning/phases/03-certificate-management/03-02-SUMMARY.md`
</output>
