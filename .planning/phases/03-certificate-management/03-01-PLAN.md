---
phase: 03-certificate-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/db/certificate.go
  - internal/db/db.go
  - internal/core/generator.go
autonomous: true

must_haves:
  truths:
    - "Certificate entity exists with fullchain_path and privkey_path"
    - "ConfigGenerator resolves certificate_id to paths when building TLS"
  artifacts:
    - path: internal/db/certificate.go
      provides: Certificate model and CRUD
      contains: "type Certificate struct"
    - path: internal/core/generator.go
      provides: cert_id resolution in vlessToSingBox and hysteria2ToSingBox
      pattern: "certificate_id|GetCertificateByID"
  key_links:
    - from: internal/core/generator.go
      to: internal/db/certificate.go
      via: db.GetCertificateByID
      pattern: "db\\.GetCertificateByID"
---

<objective>
Add Certificate model and DB layer; ConfigGenerator resolves certificate_id to fullchain_path + key_path when emitting sing-box TLS config.

Purpose: Foundation for CRT-01 (manual cert paths) and CRT-02 (cert association to inbound TLS). Enables inbounds to reference certs by ID instead of inline paths.
Output: Certificate model, CRUD, certificates table; ConfigGenerator emits certificate_path/key_path from cert lookup.
</objective>

<execution_context>
@/home/whj/.claude/get-shit-done/workflows/execute-plan.md
@/home/whj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-certificate-management/03-RESEARCH.md
@internal/db/inbound.go
@internal/core/generator.go
@internal/db/db.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Certificate model and CRUD</name>
  <files>internal/db/certificate.go, internal/db/db.go</files>
  <action>
Create internal/db/certificate.go with Certificate struct per RESEARCH:
- ID (uint, primaryKey)
- Name (string, not null) — display label
- FullchainPath (gorm column: fullchain_path, not null)
- PrivkeyPath (gorm column: privkey_path, not null)
- CreatedAt, UpdatedAt (autoCreateTime, autoUpdateTime)
- TableName() returns "certificates"

Add CRUD: ListCertificates, GetCertificateByID, CreateCertificate, UpdateCertificate, DeleteCertificate.
Follow Inbound pattern: same package, DB global, Order by created_at DESC for list.

In internal/db/db.go, add Certificate to AutoMigrate: DB.AutoMigrate(&Admin{}, &Inbound{}, &Certificate{})
</action>
  <verify>go build ./... passes; grep -E "Certificate|ListCertificates|GetCertificateByID" internal/db/</verify>
  <done>Certificate model exists; ListCertificates and GetCertificateByID work; certificates table created on startup</done>
</task>

<task type="auto">
  <name>Task 2: ConfigGenerator resolve certificate_id</name>
  <files>internal/core/generator.go</files>
  <action>
In vlessToSingBox and hysteria2ToSingBox, when copying tls from config_json to output:
- After copying tls map, check if tls["certificate_id"] exists and is valid (numeric)
- Add toUint helper: converts float64, int, int64, json.Number to uint; returns (uint, bool)
- If certificate_id present: call db.GetCertificateByID(id); if err==nil, set tls["certificate_path"]=cert.FullchainPath, tls["key_path"]=cert.PrivkeyPath
- Delete tls["certificate_id"] before emitting (sing-box does not know this field)
- If certificate_id absent or lookup fails: use existing certificate_path/key_path from config_json (backward compat)

Apply this logic in both vlessToSingBox (when tls is copied from cfg) and hysteria2ToSingBox (when tls is copied from cfg).
For vlessToSingBox: tls comes from cfg["tls"]; after out["tls"]=t, run resolve on the map we're putting in out
For hysteria2ToSingBox: same — out["tls"] gets the cfg tls; resolve before we're done

Implementation detail: Create a resolveCertInTLS(tls map[string]any) helper that modifies tls in-place. Call it on the tls map before assigning to out["tls"].
</action>
  <verify>go build ./... passes; grep -E "certificate_id|GetCertificateByID|resolveCert" internal/core/generator.go</verify>
  <done>Inbound with tls.certificate_id in config_json produces sing-box JSON with certificate_path and key_path; certificate_id not emitted</done>
</task>

</tasks>

<verification>
- go build ./...
- Migrate: start app, verify certificates table exists (sqlite3 or check logs)
- Unit/manual: Create cert via DB, create inbound with config_json tls.certificate_id, run Generate(), verify output has certificate_path and key_path
</verification>

<success_criteria>
- Certificate model and CRUD operational
- ConfigGenerator resolves certificate_id to paths; backward compat with inline paths preserved
</success_criteria>

<output>
After completion, create `.planning/phases/03-certificate-management/03-01-SUMMARY.md`
</output>
