---
phase: 08-deployment-production
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/config/panel.go
  - cmd/server/main.go
  - internal/api/core.go
  - internal/api/inbounds.go
  - internal/api/users.go
  - internal/core/process.go
  - internal/core/updater.go
  - internal/session/session.go
  - docs/reverse-proxy.md
autonomous: true

must_haves:
  truths:
    - "Panel loads config from file; env vars override file values"
    - "First run creates default config.json with random session_secret"
    - "Session cookie Secure when behind HTTPS proxy (FORCE_HTTPS)"
    - "User can deploy behind Nginx/Caddy with documented examples"
  artifacts:
    - path: internal/config/panel.go
      provides: "Panel config load/save with auto-generate"
      contains: "LoadConfig|defaultConfig"
    - path: docs/reverse-proxy.md
      provides: "Nginx and Caddy reverse proxy examples"
      contains: "proxy_pass|reverse_proxy"
  key_links:
    - from: cmd/server/main.go
      to: internal/config/panel.go
      via: "LoadConfig call"
      pattern: "config\\.LoadConfig"
    - from: internal/session/session.go
      to: "FORCE_HTTPS"
      via: "Cookie.Secure when env set"
      pattern: "Secure.*true|FORCE_HTTPS"
---

<objective>
Add panel config file with auto-generate on first run, and HTTPS proxy support (cookie Secure + reverse proxy docs).

Purpose: Enable Docker config mount and HTTPS behind reverse proxy per CONTEXT.
Output: internal/config/panel.go, refactored main/api/core to use config, docs/reverse-proxy.md
</objective>

<execution_context>
@/home/whj/.claude/get-shit-done/workflows/execute-plan.md
@/home/whj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-deployment-production/08-CONTEXT.md
@.planning/phases/08-deployment-production/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Panel config loader with auto-generate</name>
  <files>internal/config/panel.go, cmd/server/main.go, internal/api/core.go, internal/api/inbounds.go, internal/api/users.go, internal/core/process.go, internal/core/updater.go</files>
  <action>
Create internal/config/panel.go with:
- Config struct: Addr (string, default ":8080"), SessionSecret (string, 32-byte hex), DataDir (string, default "./data"), SingboxConfigPath (string, default "./sing-box.json"), SingboxBinaryPath (string, default "" meaning dataDir/bin/sing-box)
- LoadConfig(configPath string) (*Config, error): If CONFIG_PATH env is set, use it; else use env-only mode (no file, build Config from env: ADDR, DATA_DIR, SINGBOX_CONFIG_PATH, SINGBOX_BINARY_PATH) for backward compat. When CONFIG_PATH set: if file missing, defaultConfig()+random session_secret, write file, return; if exists, read and unmarshal. Apply env overrides in both modes. Default SingboxConfigPath when from file: "${data_dir}/sing-box.json".
- defaultConfig() returns Config with sensible defaults; caller fills SessionSecret before write.

Refactor cmd/server/main.go: Call config.LoadConfig at startup. Use cfg.DataDir for db path, cfg.Addr for ListenAndServe. Pass cfg to api.Routes and session.NewManager (cfg.SessionSecret for SCS key, or keep SCS as-is and add Secure in Task 2).

Refactor internal/api: configPath() and binaryPath() to accept *config.Config or read from a global/singleton. Simplest: pass config to Routes, each handler receives config. Or: init once in main, api.GetConfig() or similar. Use dependency injection: Routes(distFS, sm, cfg). core.NewProcessManager uses config. core.NewProcessManagerWithBinary(cfg.SingboxConfigPath, cfg.SingboxBinaryPath or dataDir/bin/sing-box).

Update internal/core/process.go: NewProcessManager reads from env if no config (backward compat during transition). Or: NewProcessManager accepts config. Phase 01-02 uses core.NewProcessManager() with no args. We need to change callers to pass config. Check: api/core.go, api/inbounds.go, api/users.go, core/updater.go - all use configPath() and binaryPath() or NewProcessManager. Centralize: api receives *config.Config, passes to ProcessManager. core.NewProcessManager(cfg) or NewProcessManagerWithBinary(cfg.SingboxConfigPath, binPath).

Ensure ProcessManager and Updater use config paths from the passed config.
</action>
  <verify>go build ./... succeeds; run server with CONFIG_PATH=/tmp/test-s-ui.json, verify file created and contains session_secret; run with existing file, verify loads; unset CONFIG_PATH, no file, verify falls back to env (ADDR, DATA_DIR work)</verify>
  <done>Panel loads config from file; first run auto-generates; env vars override</done>
</task>

<task type="auto">
  <name>Task 2: Session cookie Secure for HTTPS proxy</name>
  <files>internal/session/session.go, cmd/server/main.go</files>
  <action>
In internal/session/session.go: NewManager accepts optional secure bool (or read os.Getenv("FORCE_HTTPS")).
When FORCE_HTTPS is "true" or "1", set sm.Cookie.Secure = true.
Document: When behind Nginx/Caddy reverse proxy with HTTPS, set FORCE_HTTPS=true so browser sends cookie over HTTPS.

In cmd/server/main.go: Pass secure := os.Getenv("FORCE_HTTPS") == "true" || os.Getenv("FORCE_HTTPS") == "1" to session.NewManager. Or add to Config struct: ForceHTTPS bool (from env FORCE_HTTPS).
</action>
  <verify>FORCE_HTTPS=true → Cookie.Secure=true in session; FORCE_HTTPS unset → Secure=false</verify>
  <done>Cookie Secure set when behind HTTPS proxy</done>
</task>

<task type="auto">
  <name>Task 3: Reverse proxy documentation</name>
  <files>docs/reverse-proxy.md</files>
  <action>
Create docs/reverse-proxy.md with Nginx and Caddy examples per CONTEXT ("提供 Nginx/Caddy 反向代理配置示例").

Nginx example:
- server block listen 443 ssl
- ssl_certificate, ssl_certificate_key
- location / { proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; }
- Note: Set FORCE_HTTPS=true when behind this proxy

Caddy example:
- example.com { reverse_proxy :8080 }
- Caddy auto HTTPS; proxy to panel
- Note: Set FORCE_HTTPS=true when behind Caddy

Include brief intro: Panel serves HTTP only; HTTPS via reverse proxy. Port configurable via config Addr or ADDR env.
</action>
  <verify>docs/reverse-proxy.md exists; contains nginx and caddy config snippets; mentions FORCE_HTTPS</verify>
  <done>User has Nginx/Caddy examples for HTTPS</done>
</task>

</tasks>

<verification>
- go build ./... passes
- Panel starts with CONFIG_PATH pointing to new file; auto-generates on first run
- Env vars ADDR, DATA_DIR, SINGBOX_CONFIG_PATH override config file
- FORCE_HTTPS=true sets Cookie.Secure
- docs/reverse-proxy.md exists with both examples
</verification>

<success_criteria>
- Panel config file support with auto-generate
- HTTPS proxy support via FORCE_HTTPS and documented reverse proxy examples
</success_criteria>

<output>
After completion, create `.planning/phases/08-deployment-production/08-01-SUMMARY.md`
</output>
