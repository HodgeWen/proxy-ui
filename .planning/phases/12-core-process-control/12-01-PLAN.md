---
phase: 12-core-process-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/core/lifecycle_state.go
  - internal/core/lifecycle_state_test.go
  - internal/core/process.go
  - internal/api/core.go
  - internal/api/core_test.go
  - internal/api/routes.go
autonomous: true
requirements: [CORE-01, CORE-02, CORE-03, CORE-04]

must_haves:
  truths:
    - "GET /api/core/status 返回 state 且只会是 not_installed/stopped/running/error 四种之一"
    - "core 二进制缺失时，状态为 not_installed，start/restart 返回语义化错误而非假成功"
    - "running 状态可执行 stop/restart，stopped 状态可执行 start"
    - "启动失败后状态进入 error，并保留可供前端展示的最近失败上下文"
    - "error 状态可用动作为 retry_start 与 view_logs，不再误导显示 restart"
  artifacts:
    - path: "internal/core/lifecycle_state.go"
      provides: "四态状态判定、最近失败上下文、状态快照输出"
      exports: ["CoreState", "ResolveCoreState", "ActionMatrix"]
    - path: "internal/core/process.go"
      provides: "Start/Stop/Restart 独立生命周期控制与语义化错误"
      exports: ["Start", "Stop", "Restart"]
    - path: "internal/api/core.go"
      provides: "status/start/stop/restart/logs handlers 与统一错误响应"
      exports: ["StatusHandler", "StartHandler", "StopHandler", "RestartHandler", "LogsHandler"]
    - path: "internal/api/routes.go"
      provides: "核心控制新路由注册（/start /stop /restart /logs）"
      contains: "/api/core/start"
    - path: "internal/core/lifecycle_state_test.go"
      provides: "四态判定与动作矩阵测试"
    - path: "internal/api/core_test.go"
      provides: "控制接口状态码与错误语义测试"
  key_links:
    - from: "internal/api/core.go"
      to: "internal/core/lifecycle_state.go"
      via: "StatusHandler 调用状态解析并输出 action hints"
      pattern: "ResolveCoreState\\("
    - from: "internal/api/core.go"
      to: "internal/core/process.go"
      via: "Start/Stop/Restart handlers 调用对应进程控制方法"
      pattern: "\\.(Start|Stop|Restart)\\("
    - from: "internal/api/routes.go"
      to: "internal/api/core.go"
      via: "注册 /api/core/start|stop|restart|logs"
      pattern: "/(start|stop|restart|logs)"
    - from: "internal/api/core.go"
      to: "data/sing-box.log"
      via: "LogsHandler 按需读取最近日志行"
      pattern: "ReadFile|os\\.Open"
---

<objective>
建立后端 sing-box 生命周期单一真相源：四态状态模型 + 语义化 start/stop/restart 接口 + 失败上下文与日志读取能力。

Purpose: 让前端基于可靠状态与动作语义渲染，彻底消除“二进制缺失却显示成功”与“启动失败后动作误导”问题。
Output: 后端核心状态/控制 API 与测试覆盖，可直接被 Phase 12 前端计划消费。
</objective>

<execution_context>
@/home/whj/.claude/get-shit-done/workflows/execute-plan.md
@/home/whj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/12-core-process-control/12-RESEARCH.md
@internal/core/process.go
@internal/api/core.go
@internal/api/routes.go
@cmd/server/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: 实现四态生命周期模型与语义化进程控制</name>
  <files>internal/core/lifecycle_state.go, internal/core/process.go</files>
  <action>
在 `internal/core/lifecycle_state.go` 新建生命周期状态层，定义 `CoreState`（not_installed/stopped/running/error）及状态解析函数，优先级固定为 `not_installed > running > error > stopped`。同时维护最近一次启动失败上下文（错误文本、时间、阶段/来源），并提供可序列化快照给 API 使用。

在 `internal/core/process.go` 拆分并实现 `Start(configPath)`, `Stop()`, `Restart(configPath)`：
- `Start`：二进制不存在时返回明确错误码语义（用于 CORE-02），已运行时返回 already_running；
- `Stop`：未运行时返回 already_stopped，运行中则执行停止；
- `Restart`：严格由 `Stop + Start` 组合，不再允许二进制缺失时 silent no-op。

启动流程加入短窗口健康复核（建议 500ms 左右）：`cmd.Start()` 成功但进程立即退出时，归类为 start_failed 并写入最近失败上下文（用于 CORE-03）。保持无新增依赖，仅使用 Go 标准库。
  </action>
  <verify>
- `go test ./internal/core` 通过；
- 手工调用状态解析：缺失二进制时返回 `not_installed`，有失败上下文且未运行时返回 `error`；
- 代码中不再存在“`!Available()` 返回 nil 成功”的重启分支。
  </verify>
  <done>
- 进程控制方法具备明确状态语义，且不会在缺失二进制时误报成功；
- 后端可输出四态 + 失败上下文 + 对应可用动作矩阵基础数据。
  </done>
</task>

<task type="auto">
  <name>Task 2: 改造 Core API 为状态驱动动作接口</name>
  <files>internal/api/core.go, internal/api/routes.go</files>
  <action>
改造 `StatusHandler` 响应结构，新增 `state`、`actions`、`lastError`（保留 `running` 字段用于短期兼容，避免破坏现有调用）。`actions` 必须遵守：
- running: stop, restart
- stopped: start
- not_installed: install
- error: retry_start, view_logs

新增并注册独立控制路由：
- `POST /api/core/start`
- `POST /api/core/stop`
- `POST /api/core/restart`（保留但语义正确）
- `GET /api/core/logs?lines=N`（默认读取最近 N 行，非实时）

统一错误响应结构（例如 `{ code, message, detail }`），确保前端可区分 `CORE_NOT_INSTALLED`、`CORE_ALREADY_RUNNING`、`CORE_ALREADY_STOPPED`、`CORE_START_FAILED`。明确保持状态获取方式为 TanStack Query 轮询消费（不引入 SSE 状态流）。
  </action>
  <verify>
- `go test ./internal/api` 通过；
- `curl -X GET /api/core/status` 返回 `state` 且值属于四态枚举；
- 在二进制缺失时 `curl -X POST /api/core/start` 返回 4xx + `code=CORE_NOT_INSTALLED`；
- 启动失败场景下 `GET /api/core/status` 返回 `state=error` 且 `actions` 包含 `retry_start`、`view_logs`。
  </verify>
  <done>
- 后端 API 已完整支持四态状态与 start/stop/restart 拆分；
- 状态响应与动作语义一一对应，可直接驱动前端按钮渲染。
  </done>
</task>

<task type="auto">
  <name>Task 3: 增补后端测试覆盖四态与动作语义</name>
  <files>internal/core/lifecycle_state_test.go, internal/api/core_test.go</files>
  <action>
编写针对四态与动作语义的最小充分测试：
- 生命周期解析测试：覆盖 not_installed/stopped/running/error 四态与优先级；
- 控制接口测试：覆盖 start/stop/restart 语义化状态码和错误码；
- error 状态测试：模拟启动失败后 status 返回动作矩阵包含 retry_start + view_logs；
- logs 接口测试：日志文件存在与不存在两条路径。

测试应避免引入新依赖，复用现有 Go testing/http 测试模式。
  </action>
  <verify>
- `go test ./internal/core ./internal/api` 全部通过；
- 测试断言显式覆盖四态枚举与关键错误码（含 CORE_NOT_INSTALLED、CORE_START_FAILED）。
  </verify>
  <done>
- Phase 12 后端关键行为具备可回归测试；
- 四态与动作语义在后续改动中可被自动守护。
  </done>
</task>

</tasks>

<verification>
1. `go test ./internal/core ./internal/api` 通过。
2. 手工 API 冒烟验证四态与动作矩阵：
   - 缺失 core 时 `status.state=not_installed`
   - 正常运行时 `status.state=running` 且动作为 stop/restart
   - 主动停止后 `status.state=stopped` 且动作为 start
   - 启动失败后 `status.state=error` 且动作为 retry_start/view_logs
3. `GET /api/core/logs` 在非实时模式可返回最近日志片段（或明确日志不存在错误）。
</verification>

<success_criteria>
- CORE-04：后端状态接口稳定输出四态；
- CORE-01：后端已提供独立 start/stop/restart 并返回语义化结果；
- CORE-02：二进制缺失时不会自动进入“可运行”语义，控制接口不再假成功；
- CORE-03：启动失败后进入 error 并暴露重试与日志动作基础数据。
</success_criteria>

<output>
After completion, create `.planning/phases/12-core-process-control/12-01-SUMMARY.md`
</output>
