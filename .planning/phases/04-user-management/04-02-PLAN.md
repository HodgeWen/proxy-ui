---
phase: 04-user-management
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - internal/api/users.go
  - internal/api/routes.go
autonomous: true

must_haves:
  truths:
    - "GET /api/users returns list with optional search"
    - "GET /api/users/:id returns user detail with inbound_ids"
    - "POST/PUT/DELETE /api/users trigger ApplyConfig + Restart on success"
    - "POST /api/users/batch supports delete, enable, disable, reset_traffic"
  artifacts:
    - path: internal/api/users.go
      provides: User REST API and batch endpoint
      exports: ["ListUsersHandler", "GetUserHandler", "CreateUserHandler", "UpdateUserHandler", "DeleteUserHandler", "BatchUsersHandler"]
    - path: internal/api/routes.go
      provides: /api/users routes
      contains: "/users"
  key_links:
    - from: internal/api/users.go
      to: internal/core/generator.go
      via: "Generate + ApplyConfig after mutate"
      pattern: "ApplyConfig|ConfigGenerator"
    - from: internal/api/users.go
      to: internal/db/user.go
      via: "CRUD and batch operations"
      pattern: "db\\.(Create|Update|Delete|List)User"
---

<objective>
User REST API with CRUD and batch operations; all mutations trigger ConfigGenerator + ApplyConfig + Restart per Phase 2 pattern.

Purpose: Enable frontend to manage users; batch operations for USR-09.
Output: internal/api/users.go, routes.go /api/users
</objective>

<execution_context>
@/home/whj/.claude/get-shit-done/workflows/execute-plan.md
@/home/whj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-user-management/04-CONTEXT.md
@.planning/phases/04-user-management/04-RESEARCH.md
@internal/api/inbounds.go
@internal/api/certs.go
@internal/db/user.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: User CRUD API</name>
  <files>internal/api/users.go, internal/api/routes.go</files>
  <action>
Create internal/api/users.go following inbounds.go and certs.go patterns:

1. GET /api/users: ListUsersHandler
   - Query param "q" (optional): pass to db.ListUsers as keyword filter
   - Return { data: [ { id, name, remark, uuid, password, traffic_limit, traffic_used, expire_at, enabled, created_at, inbound_ids, inbound_tags } ] }
   - inbound_ids: array of inbound IDs; inbound_tags: array of tag strings for display (from Preload Inbounds)

2. GET /api/users/:id: GetUserHandler
   - Return same shape with inbound_ids for edit form

3. POST /api/users: CreateUserHandler
   - Body: { name, remark, inbound_ids?: number[], traffic_limit?: number, expire_at?: string }
   - Generate UUID and Password via uuid.NewString() if empty
   - Create user, associate inbounds via GORM Association
   - Flow: db.CreateUser -> gen.Generate -> ApplyConfig; on ApplyConfig failure: db.DeleteUser, return 400 with error
   - On success: Restart (best-effort), return 201

4. PUT /api/users/:id: UpdateUserHandler
   - Body: same as create
   - Replace inbound associations (clear + set new)
   - Flow: db.UpdateUser -> Generate -> ApplyConfig; on failure rollback (revert update), return 400

5. DELETE /api/users/:id: DeleteUserHandler
   - Flow: db.DeleteUser -> Generate -> ApplyConfig; on failure: recreate user (rollback), return 400

6. Add RequireAuth and routes in routes.go: /api/users GET, GET/:id, POST, PUT/:id, DELETE/:id

Response shapes: traffic_used (int64), traffic_limit (int64), expire_at (ISO date or null). Use time.RFC3339 for expire_at in API.
  </action>
  <verify>curl -s -b cookies.txt http://localhost:8080/api/users returns 200 with data array</verify>
  <done>User CRUD works; mutations trigger ApplyConfig; rollback on failure</done>
</task>

<task type="auto">
  <name>Task 2: Batch API</name>
  <files>internal/api/users.go</files>
  <action>
Add POST /api/users/batch handler:

1. Body: { "action": "delete"|"enable"|"disable"|"reset_traffic", "ids": [1,2,3] }

2. Validate: action required, ids non-empty array

3. For each action:
   - delete: db.DeleteUser for each id (in transaction; rollback all on ApplyConfig failure)
   - enable: db.UpdateUser set Enabled=true
   - disable: db.UpdateUser set Enabled=false
   - reset_traffic: db.UpdateUser set TrafficUsed=0

4. Use DB transaction: Begin, apply all mutations, Generate, ApplyConfig; if ApplyConfig fails then Rollback and return 400; else Commit. All batch operations wrapped in transaction for atomic rollback.

5. On success: Restart (best-effort), return 200

6. Add route: POST /api/users/batch

Per CONTEXT: batch delete, enable, disable, reset_traffic.
  </action>
  <verify>curl -X POST -H "Content-Type: application/json" -d '{"action":"disable","ids":[1]}' -b cookies.txt /api/users/batch returns 200</verify>
  <done>Batch endpoint works; all actions trigger ApplyConfig</done>
</task>

</tasks>

<verification>
- go build ./...
- All CRUD and batch endpoints respond correctly
- ApplyConfig and Restart invoked on mutations
</verification>

<success_criteria>
- User API complete with search and batch
- Rollback on ApplyConfig failure per Phase 2 pattern
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-management/04-02-SUMMARY.md`
</output>
