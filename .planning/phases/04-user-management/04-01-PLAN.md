---
phase: 04-user-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/db/user.go
  - internal/db/db.go
  - internal/core/generator.go
autonomous: true

must_haves:
  truths:
    - "User model exists with UUID, Password, TrafficLimit, TrafficUsed, ExpireAt, Enabled"
    - "UserInbound many-to-many links User to Inbound"
    - "ConfigGenerator builds users array per inbound from User+UserInbound, not config_json"
    - "Only enabled users with traffic under limit and not expired are included"
  artifacts:
    - path: internal/db/user.go
      provides: User model, UserInbound, CRUD, ListWithFilter
      contains: "type User struct"
    - path: internal/core/generator.go
      provides: User-derived sing-box users per inbound
      contains: "db.ListUsers"
  key_links:
    - from: internal/core/generator.go
      to: internal/db/user.go
      via: "Query ListUsers + UserInbound for each inbound"
      pattern: "db\\.ListUsers|db\\.GetUsersForInbound"
---

<objective>
Add User model with UserInbound many-to-many; change ConfigGenerator to derive sing-box users from DB instead of config_json.

Purpose: Foundation for user management; ConfigGenerator must filter disabled/over-limit/expired users per CONTEXT.
Output: internal/db/user.go (User, UserInbound, CRUD), db.go AutoMigrate, generator.go user filtering
</objective>

<execution_context>
@/home/whj/.claude/get-shit-done/workflows/execute-plan.md
@/home/whj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-user-management/04-CONTEXT.md
@.planning/phases/04-user-management/04-RESEARCH.md
@internal/db/inbound.go
@internal/core/generator.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: User model and UserInbound</name>
  <files>internal/db/user.go, internal/db/db.go</files>
  <action>
Create internal/db/user.go with:

1. User struct (per RESEARCH):
   - ID, Name (size 100, not null), Remark (size 255)
   - UUID (size 36, uniqueIndex), Password (size 255)
   - TrafficLimit (int64, default 0), TrafficUsed (int64, default 0)
   - ExpireAt (*time.Time), Enabled (bool, default true)
   - CreatedAt, UpdatedAt
   - Inbounds []Inbound `gorm:"many2many:user_inbounds;"`

2. CRUD: ListUsers(filter optional), GetUserByID, CreateUser, UpdateUser, DeleteUser
   - ListUsers: accept optional keyword (search name/remark), return ordered by created_at DESC
   - CreateUser: auto-generate UUID via github.com/google/uuid (uuid.NewString()) for new users; auto-generate Password same way (Hysteria2)
   - CreateUser: replace empty UUID/Password with generated values

3. GetUsersForInbound(inboundID uint) ([]User, error): returns users assigned to this inbound who are valid:
   - Enabled == true
   - TrafficLimit == 0 OR TrafficUsed < TrafficLimit
   - ExpireAt == nil OR ExpireAt.After(time.Now().UTC())
   Use Preload("Inbounds") and filter by inbound ID in user_inbounds. Filter in memory after fetch to apply valid logic.

4. Add User to AutoMigrate in db.go

Do NOT store users in Inbound config_json. User model is source of truth per RESEARCH.
  </action>
  <verify>go build ./internal/db/... passes; User and user_inbounds tables exist after app init</verify>
  <done>User CRUD works; GetUsersForInbound returns only valid users for given inbound</done>
</task>

<task type="auto">
  <name>Task 2: ConfigGenerator user derivation</name>
  <files>internal/core/generator.go</files>
  <action>
Modify ConfigGenerator (vlessToSingBox and hysteria2ToSingBox):

1. STOP reading users from config_json. Remove the cfg["users"] block in vlessToSingBox (lines 60-64). Never use config_json for users.

2. For each inbound, call db.GetUsersForInbound(ib.ID) to get valid users.

3. VLESS: build users array as []map[string]any with format:
   {"name": user.Name, "uuid": user.UUID, "flow": "xtls-rprx-vision"}
   Same user on multiple VLESS inbounds shares one UUID (from User model).

4. Hysteria2: build users array as []map[string]any with format:
   {"name": user.Name, "password": user.Password}

5. If no users assigned, emit users: [] (empty array).

Per CONTEXT: ConfigGenerator filters disabled/over-limit/expired; only valid users appear in sing-box config.
  </action>
  <verify>go build ./internal/core/... passes; Generate produces users array from User+UserInbound when users exist</verify>
  <done>ConfigGenerator builds users from DB; config_json users ignored</done>
</task>

</tasks>

<verification>
- go build ./...
- User table and user_inbounds junction exist
- ConfigGenerator includes users from User+UserInbound, not config_json
</verification>

<success_criteria>
- User model with all CONTEXT fields
- ConfigGenerator derives users from DB; valid filter applied
- No users read from inbound config_json
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-management/04-01-SUMMARY.md`
</output>
