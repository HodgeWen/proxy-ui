---
phase: 10-sidebar-pages-config-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/core/config.go
  - internal/core/process.go
  - internal/core/updater.go
  - internal/api/core.go
  - internal/api/users.go
  - internal/api/inbounds.go
  - internal/api/certs.go
  - internal/api/stats.go
  - internal/api/routes.go
  - cmd/server/main.go
  - docker-compose.yml
autonomous: true
requirements: [UX-01]

must_haves:
  truths:
    - "ApplyConfig uses the correct sing-box binary path from panel config, not env-only default"
    - "NewProcessManager() env-only constructor is deleted"
    - "ConfigPathFromEnv() dead code is deleted"
    - "GET /api/stats/summary returns inbound_count, user_count, active_user_count, total_uplink, total_downlink"
    - "GET /api/core/config-file returns current sing-box config JSON (or 404 if no config yet)"
    - "Startup logs warning if sing-box binary not found at configured path"
  artifacts:
    - path: "internal/core/config.go"
      provides: "ApplyConfig with *ProcessManager parameter"
      contains: "func ApplyConfig(configPath string, configJSON []byte, pm *ProcessManager)"
    - path: "internal/api/stats.go"
      provides: "Stats summary endpoint"
      exports: ["StatsSummaryHandler"]
    - path: "internal/api/core.go"
      provides: "Config file viewer endpoint"
      contains: "ConfigFileHandler"
  key_links:
    - from: "internal/api/core.go"
      to: "internal/core/config.go"
      via: "core.ApplyConfig with pm parameter"
      pattern: "core\\.ApplyConfig\\(path,.+, pm\\)"
    - from: "internal/api/users.go"
      to: "internal/core/config.go"
      via: "core.ApplyConfig with pm parameter"
      pattern: "core\\.ApplyConfig\\(path,.+, pm\\)"
    - from: "internal/api/routes.go"
      to: "internal/api/stats.go"
      via: "route registration"
      pattern: "stats/summary.*StatsSummaryHandler"
---

<objective>
Fix config path inconsistencies in the Go backend and add two new API endpoints for the Dashboard stats overview and Core config viewer.

Purpose: The current `ApplyConfig()` uses `NewProcessManager()` which defaults to `./config.json` — wrong path. This silently breaks `sing-box check` when `SINGBOX_BINARY_PATH` is set in panel config but not in env. Also, the refactored Dashboard and new Core page need dedicated endpoints for stats aggregation and config file viewing.

Output: Fixed `ApplyConfig` signature, removed dead code, two new endpoints registered, startup validation added, Docker config updated.
</objective>

<execution_context>
@/home/whj/.claude/get-shit-done/workflows/execute-plan.md
@/home/whj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-sidebar-pages-config-fix/10-RESEARCH.md

@internal/core/config.go
@internal/core/process.go
@internal/core/updater.go
@internal/api/core.go
@internal/api/users.go
@internal/api/inbounds.go
@internal/api/certs.go
@internal/api/routes.go
@cmd/server/main.go
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix ApplyConfig signature, remove dead code, update all callers</name>
  <files>
    internal/core/config.go
    internal/core/process.go
    internal/core/updater.go
    internal/api/core.go
    internal/api/users.go
    internal/api/inbounds.go
    internal/api/certs.go
    cmd/server/main.go
    docker-compose.yml
  </files>
  <action>
**internal/core/config.go:**
Change `ApplyConfig` signature from `func ApplyConfig(configPath string, configJSON []byte) error` to `func ApplyConfig(configPath string, configJSON []byte, pm *ProcessManager) error`. Remove the line `pm := NewProcessManager()` inside the function body — the pm is now passed in.

**internal/core/process.go:**
Delete the entire `NewProcessManager()` function (lines 21-32). Keep `NewProcessManagerFromConfig` and `NewProcessManagerWithBinary`.

**internal/core/updater.go:**
Delete the entire `ConfigPathFromEnv()` function (lines 332-338). Then find where `ConfigPathFromEnv()` is referenced in the same file (CoreUpdater methods) — if `Update()` or `Rollback()` use it, replace with the configPath from the ProcessManager they already construct via `NewProcessManagerWithBinary`. Check: the updater.go `Update()` and `Rollback()` methods create PMs with `NewProcessManagerWithBinary(ConfigPathFromEnv(), u.binaryPath)` — change these to accept configPath as a parameter or use the PM's `ConfigPath()` method. Specifically, check if `CoreUpdater` needs a `configPath` field. The cleanest fix: add `configPath string` field to `CoreUpdater` struct, set it when creating `NewCoreUpdater` in api/core.go (from `configPath(cfg)`), and use `u.configPath` instead of `ConfigPathFromEnv()`.

**internal/api/core.go:**
The `ConfigHandler` (POST /api/core/config) already has `cfg *config.Config`. Update its `core.ApplyConfig(path, body)` call to `core.ApplyConfig(path, body, pm)` where `pm := core.NewProcessManagerFromConfig(cfg)`. Similarly update the `NewCoreUpdater` call to pass `configPath(cfg)` as the config path.

**internal/api/users.go:**
There are 4 calls to `core.ApplyConfig`. Each handler already receives `cfg *config.Config`. For each call:
- Create `pm := core.NewProcessManagerFromConfig(cfg)` before the ApplyConfig call (or reuse if already created for Restart later)
- Change `core.ApplyConfig(path, cfg)` → `core.ApplyConfig(path, cfg, pm)`
- If pm is already created below for `pm.Restart(path)`, move the creation above the ApplyConfig call and reuse

**internal/api/inbounds.go:**
Same pattern as users.go — 3 calls to `core.ApplyConfig`. Each handler receives `cfg`. Create pm once, use for both ApplyConfig and Restart.

**internal/api/certs.go:**
1 call to `core.ApplyConfig` in `UpdateCertificateHandler`. This handler already creates `pm := core.NewProcessManagerFromConfig(panelCfg)` for Restart — move it above the ApplyConfig call and pass it.

**cmd/server/main.go:**
After `cfg, err := config.LoadConfig()` and before starting the HTTP server, add startup validation:
```go
pm := core.NewProcessManagerFromConfig(cfg)
if !pm.Available() {
    log.Printf("[warn] sing-box binary not found at configured path: %s", cfg.SingboxBinaryPath)
}
```
Also ensure config directory exists: `_ = os.MkdirAll(filepath.Dir(cfg.SingboxConfigPath), 0755)`.

**docker-compose.yml:**
Add `SINGBOX_BINARY_PATH: /usr/local/bin/sing-box` to the environment section for explicitness.
  </action>
  <verify>
`cd /home/whj/codes/s-ui && go build ./...` compiles with zero errors. `rg 'NewProcessManager\(\)' internal/` returns zero matches. `rg 'ConfigPathFromEnv' internal/` returns zero matches. `rg 'core\.ApplyConfig' internal/api/` shows all calls have 3 arguments.
  </verify>
  <done>
ApplyConfig accepts *ProcessManager parameter. NewProcessManager() deleted. ConfigPathFromEnv() deleted. All 9 callers updated. Startup validates sing-box binary path. docker-compose.yml has explicit SINGBOX_BINARY_PATH.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add stats summary and config file viewer endpoints</name>
  <files>
    internal/api/stats.go
    internal/api/core.go
    internal/api/routes.go
  </files>
  <action>
**internal/api/stats.go (NEW FILE):**
Create `StatsSummaryHandler(sm *scs.SessionManager) http.HandlerFunc` that returns JSON:
```json
{
  "inbound_count": N,
  "user_count": N,
  "active_user_count": N,
  "total_uplink": N,
  "total_downlink": N
}
```
Implementation: Use GORM queries on db.DB:
- `db.DB.Model(&db.Inbound{}).Count(&inboundCount)`
- `db.DB.Model(&db.User{}).Count(&userCount)`
- `db.DB.Model(&db.User{}).Where("enabled = ?", true).Count(&activeUserCount)`
- `db.DB.Model(&db.Inbound{}).Select("COALESCE(SUM(traffic_uplink), 0) as total").Scan(&uplinkResult)`
- `db.DB.Model(&db.Inbound{}).Select("COALESCE(SUM(traffic_downlink), 0) as total").Scan(&downlinkResult)`

Set `Content-Type: application/json`, encode with `json.NewEncoder(w).Encode(...)`.

**internal/api/core.go:**
Add `ConfigFileHandler(sm *scs.SessionManager, cfg *config.Config) http.HandlerFunc` that:
- Reads the file at `configPath(cfg)` (the existing helper function)
- If file doesn't exist (`os.IsNotExist`), return 404 with `{"error": "config file not found"}`
- If other read error, return 500
- On success, set `Content-Type: application/json` and write file contents

**internal/api/routes.go:**
Inside the `/api/core` route group, add: `r.Get("/config-file", ConfigFileHandler(sm, cfg))`
Add a new `/api/stats` route group with RequireAuth: `r.Route("/stats", func(r chi.Router) { r.Use(RequireAuth(sm)); r.Get("/summary", StatsSummaryHandler(sm)) })`
  </action>
  <verify>
`go build ./...` succeeds. `curl -s http://localhost:8080/api/stats/summary` returns JSON with expected fields (after login). `curl -s http://localhost:8080/api/core/config-file` returns JSON config or 404.
  </verify>
  <done>
GET /api/stats/summary returns counts and traffic totals. GET /api/core/config-file returns sing-box config JSON or 404 for fresh installs. Both endpoints registered with RequireAuth.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` — zero compilation errors
2. `rg 'NewProcessManager\(\)' internal/` — zero matches (dead code removed)
3. `rg 'ConfigPathFromEnv' internal/` — zero matches (dead code removed)
4. `rg 'core\.ApplyConfig' internal/api/ -A1` — all calls have 3 args (path, json, pm)
5. `rg 'StatsSummaryHandler' internal/api/` — exists in stats.go and routes.go
6. `rg 'ConfigFileHandler' internal/api/` — exists in core.go and routes.go
7. `rg 'SINGBOX_BINARY_PATH' docker-compose.yml` — present
</verification>

<success_criteria>
- Go project compiles cleanly
- No env-only ProcessManager constructors remain
- All ApplyConfig callers pass *ProcessManager
- Two new GET endpoints registered and functional
- Startup logs binary path warning when sing-box not found
- docker-compose.yml explicitly sets SINGBOX_BINARY_PATH
</success_criteria>

<output>
After completion, create `.planning/phases/10-sidebar-pages-config-fix/10-01-SUMMARY.md`
</output>
